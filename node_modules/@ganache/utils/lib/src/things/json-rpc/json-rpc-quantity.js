"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quantity = void 0;
const buffer_to_bigint_1 = require("../../utils/buffer-to-bigint");
const json_rpc_base_types_1 = require("./json-rpc-base-types");
const constants_1 = require("../../utils/constants");
class Quantity extends json_rpc_base_types_1.BaseJsonRpcType {
    static from(value, nullable = false) {
        if (value instanceof Quantity)
            return value;
        return new Quantity(value, nullable);
    }
    constructor(value, nullable) {
        super(value);
        this._nullable = false;
        if (value === "0x") {
            throw new Error('Cannot wrap "0x" as a json-rpc Quantity type; strings must contain at least one hexadecimal character.');
        }
        this._nullable = nullable;
    }
    toString() {
        if (this.bufferValue == null) {
            return this._nullable ? null : Quantity.ZERO_VALUE_STRING;
        }
        const firstNonZeroByte = this.findFirstNonZeroByteIndex();
        // bufferValue is empty, or contains only 0 bytes
        if (firstNonZeroByte === this.bufferValue.length) {
            return Quantity.ZERO_VALUE_STRING;
        }
        let value = this.bufferValue.toString("hex", firstNonZeroByte);
        // only need to check the first char, as we have already skipped 0 bytes in call to this.bufferValue.toString().
        if (value[0] === "0") {
            value = value.slice(1);
        }
        return `0x${value}`;
    }
    toBuffer() {
        if (this.bufferValue == null) {
            return constants_1.BUFFER_EMPTY;
        }
        const firstNonZeroByte = this.findFirstNonZeroByteIndex();
        if (firstNonZeroByte > 0) {
            return this.bufferValue.subarray(firstNonZeroByte);
        }
        else {
            return this.bufferValue;
        }
    }
    toBigInt() {
        if (this.bufferValue == null) {
            return this._nullable ? null : 0n;
        }
        if (this.bufferValue.length === 0) {
            return 0n;
        }
        return (0, buffer_to_bigint_1.bufferToBigInt)(this.bufferValue);
    }
    toNumber() {
        if (this.bufferValue == null) {
            return this._nullable ? null : 0;
        }
        const firstNonZeroByte = this.findFirstNonZeroByteIndex();
        const length = this.bufferValue.length - firstNonZeroByte;
        if (length === 0) {
            return 0;
        }
        let result;
        // buffer.readUIntBE only supports up to 48 bits, so if larger then we need to convert to bigint first
        if (length > 6) {
            const trimmedBuffer = firstNonZeroByte === 0
                ? this.bufferValue
                : this.bufferValue.subarray(firstNonZeroByte);
            result = Number((0, buffer_to_bigint_1.bufferToBigInt)(trimmedBuffer));
            if (!Number.isSafeInteger(result)) {
                console.warn(`0x${this.bufferValue.toString("hex")} is too large - the maximum safe integer value is 0${Number.MAX_SAFE_INTEGER.toString(16)}`);
            }
        }
        else {
            result = this.bufferValue.readUIntBE(firstNonZeroByte, length);
        }
        return result;
    }
    valueOf() {
        if (this.bufferValue == null) {
            return null;
        }
        else {
            return this.toBigInt();
        }
    }
    findFirstNonZeroByteIndex() {
        let firstNonZeroByte = 0;
        for (firstNonZeroByte = 0; firstNonZeroByte < this.bufferValue.length; firstNonZeroByte++) {
            if (this.bufferValue[firstNonZeroByte] !== 0)
                break;
        }
        return firstNonZeroByte;
    }
    static toBuffer(value, nullable) {
        return Quantity.from(value, nullable).toBuffer();
    }
    static toString(value, nullable) {
        return Quantity.from(value, nullable).toString();
    }
    static toNumber(value, nullable) {
        return Quantity.from(value, nullable).toNumber();
    }
    static toBigInt(value, nullable) {
        return Quantity.from(value, nullable).toBigInt();
    }
}
exports.Quantity = Quantity;
Quantity.Empty = Quantity.from(constants_1.BUFFER_EMPTY, true);
Quantity.Zero = Quantity.from(constants_1.BUFFER_ZERO);
Quantity.One = Quantity.from(1);
Quantity.Gwei = Quantity.from(1000000000);
Quantity.ZERO_VALUE_STRING = "0x0";
exports.default = Quantity;
//# sourceMappingURL=json-rpc-quantity.js.map